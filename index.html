<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Квест MYSQL(Денисов)</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
	<link rel="stylesheet" href="styles/default.css">
	<style>
		p {
			padding-top: 2.5em;
		}

		h4 {
			padding-top: 3em;
		}
	</style>

</head>

<body>
	<div class="container">
		<div class="nav flex-column nav-pills fixed-top" id="v-pills-tab" role="tablist" aria-orientation="vertical">
			<a class="nav-link" href="#task1">Задание 1 CREAT</a>
			<a class="nav-link" href="#task2">Задание 2 INSERT</a>
			<a class="nav-link" href="#task3.1">Задание 3.1 SELECT</a>
			<a class="nav-link" href="#task3.2">Задание 3.2 JOHN</a>
			<a class="nav-link" href="#task4.1">Задание 4.1 INDEX</a>
			<a class="nav-link" href="#task4.2">Задание 4.2 EXPLAIN</a>
			<a class="nav-link" href="#task5">Задание 5 </a>
		</div>
		<a href=""></a>
		<section>
			<h2 id="task1">Задание 1. Создание базы данных для сайта агентства недвижимости</h2>
			<p>Задание: Спроектировать БД агентства недвижимости: результатом должны стать: схема БД в .png, .mwb и .sql скрипт создания базы, база на сервере в облаке</p>
			<div>

				<img class="border border-secondary" src="https://d.radikal.ru/d21/1803/1d/c1922e689208.png" alt="">
				<div class="my-4">
					<div>Ссылки на скачивание:</div>
					<div><a href="https://cloud.mail.ru/public/NBkA/QFWNzcxTe">quest_bl_db.mwb</a></div>
					<div><a href="https://cloud.mail.ru/public/GrEa/1LpTfHud5">quest_bl_db.pdf</a></div>
				</div>

				<pre class="border border-success"><code class="SQL">
SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';

CREATE SCHEMA IF NOT EXISTS `mydb` DEFAULT CHARACTER SET utf8 ;
USE `mydb` ;

CREATE TABLE IF NOT EXISTS `mydb`.`estate_objects` (
  `idreal estate_objects` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `type` ENUM('дом', 'квартира', 'склад', 'офис', 'гараж', 'дача') NULL,
  `area` SMALLINT UNSIGNED NULL DEFAULT 0,
  `adress` VARCHAR(100) NULL,
  `post_index` MEDIUMINT UNSIGNED NULL,
  `rooms` TINYINT UNSIGNED NULL DEFAULT 0,
  `description` VARCHAR(3000) NULL,
  `price` VARCHAR(45) NULL,
  PRIMARY KEY (`idreal estate_objects`),
  UNIQUE INDEX `idreal estate-objects_UNIQUE` (`idreal estate_objects` ASC))
ENGINE = InnoDB;

CREATE TABLE IF NOT EXISTS `mydb`.`customers` (
  `idcustomers` INT UNSIGNED NOT NULL,
  `first_name` VARCHAR(33) NOT NULL DEFAULT 'Фамилия',
  `last_name` VARCHAR(33) NOT NULL DEFAULT 'Имя',
  `age` TINYINT UNSIGNED NULL,
  `gender` ENUM('male', 'female') NULL,
  `date_of_birth` DATE NULL,
  `phone_number` CHAR(10) NOT NULL DEFAULT 'Телефон',
  `email` VARCHAR(45) NOT NULL DEFAULT 'e-mail',
  `estate_objects_idreal estate_objects` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`idcustomers`),
  UNIQUE INDEX `idcustomers_UNIQUE` (`idcustomers` ASC),
  INDEX `fk_customers_estate_objects_idx` (`estate_objects_idreal estate_objects` ASC),
  UNIQUE INDEX `phone_number_UNIQUE` (`phone_number` ASC),
  UNIQUE INDEX `email_UNIQUE` (`email` ASC),
  UNIQUE INDEX `estate_objects_idreal estate_objects_UNIQUE` (`estate_objects_idreal estate_objects` ASC),
  CONSTRAINT `fk_customers_estate_objects`
    FOREIGN KEY (`estate_objects_idreal estate_objects`)
    REFERENCES `mydb`.`estate_objects` (`idreal estate_objects`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
</code></pre>
			</div>
		</section>
		<!--------------------------------------------------------------------------->
		<section>
			<h2 class="mt-5" id="task2">Задание 2.</h2>
			<p>Задание: Написать вопросы на вставку данных в таблицы: insert, load data. Вставить данные в разработанную БД. Данные должны быть максимально приближены к реальным.</p>
			<div>

				<h4>Запрос на вставку данных INSERT</h4>
				<pre class="border border-success"> <code class="SQL">
INSERT INTO estate_objects
SET type = 'квартира', area = '77' , adress = 'Москва', post_index = '142222',
rooms = '3', description = 'Большая престижная квартира в сталинке', price = '30000000';
				</code></pre>

				<img src="https://a.radikal.ru/a03/1803/4a/d0b9f592bc0c.png" alt="">
				<img class="border border-secondary" src="#" alt="">

				<h4 class="mt-3">Запрос на вставку данных LOAD DATA</h4>
				<p>Создаем .csv в котором заполняем поля соответственно таблице в которую будем будем вставлять. Перекодируем из windows-1251 в UTF-8</p>
				<img class="border border-secondary" src="https://c.radikal.ru/c08/1803/ef/aeec61ec13ee.png" alt="">

				<p class="mt-4">Cпрашиваем у mysql в какую в какую папку нужно положить .csv</p>
				<pre class="border border-success"><code class="SQL">SHOW VARIABLES LIKE "secure_file_priv";</code></pre>
				<img src="https://c.radikal.ru/c08/1803/00/69b71cc6e3c3.png" alt="">
				<p class="mt-4">Пишем запрос:</p>
				<pre class="border border-success"><code class="SQL">LOAD DATA INFILE 'C:/ProgramData/MySQL/MySQL Server 5.7/Uploads/customers.csv'
INTO TABLE customers
FIELDS TERMINATED BY ';' -- Excel делит ячейки не запятой а точкой с запятой
LINES TERMINATED BY '\r\n'
IGNORE 1 ROWS;
			</code></pre>


				<img class="border border-secondary" src="https://b.radikal.ru/b29/1803/de/2ec23a14ee38.png" alt="">
			</div>
		</section>
		<section>
			<h2 class="mt-5" id="task3.1">Задание 3.1</h2>
			<p>Задание. Написать запросы на выборку из таблиц базы:

			</p>
			<ul>
				<li>3.1 все варианты select из методички по курсу</li>
				<li>3.2 запросы на объединение таблиц (JOIN) между сочетаниями по две, три таблицы (не менее 10 штук) Примечание: Запросы должны гибко выбирать данные из базы</li>
			</ul>

			<h4>Запросы на выборку данных SELECT</h4>
			<p>C помощью SELECT можно осуществлять маематические процедуры не затрагивая существующие таблицы, при этом оператор SELECT всё возврвщает в виде таблицы:</p>

			<pre class="border border-success"><code class="SQL">SELECT 2+2*2;</code></pre>
			<img src="https://b.radikal.ru/b14/1803/f2/74dc0af6a316.png" alt="">

			<p>Можно отобразить все значения в определенной таблице используя *:</p>
			<pre class="border border-success"><code class="SQL">SELECT * FROM estate_objects;</code></pre>
			<img src="https://b.radikal.ru/b24/1803/95/4f00e08e663f.png" alt="">

			<p>Можно отобразить несколько столбцов из определенной таблицы:</p>
			<pre class="border border-success"><code class="SQL">SELECT last_name,date_of_birth FROM customers;</code></pre>
			<img src="https://a.radikal.ru/a31/1803/d0/40bcf9abc741.png" alt="">

			<p>Можно отобразить несколько неповторяющихся значений из определенной таблицы:</p>
			<pre class="border border-success"><code class="SQL">SELECT DISTINCT age FROM customers;</code></pre>
			<img src="https://b.radikal.ru/b16/1804/d2/e9741c60fcb8.png" alt="">

			<p>Можем осуществить математическую операцию со всеми ячейками определенного столбца таблицы</p>
			<pre class="border border-success"><code class="SQL">SELECT age +10 FROM customers;</code></pre>
			<img src="https://d.radikal.ru/d08/1804/d8/d3b4588e2f75.png" alt="">

			<p>Можем использовать клаузулу ORDER например отсортировав клиентов в алфавитном порядке отобразив сначала фамилию, а потом имя</p>
			<pre class="border border-success"><code class="SQL">SELECT last_name,first_name
FROM customers
ORDER BY last_name;</code></pre>
			<img src="https://a.radikal.ru/a23/1804/a4/a1adb9f30aba.png" alt="">

			<p>Добавляем DESC после имени колонки и получаем выборку в обратной алфавитному порядку</p>
			<pre class="border border-success"><code class="SQL">SELECT last_name,first_name
FROM customers
ORDER BY last_name DESC;			
			</code></pre>
			<img src="https://d.radikal.ru/d12/1804/35/aa892e5b3401.png" alt="">

			<p>Делаем запрос с обратной сортировкой по возрасту и фамилии</p>
			<pre class="border border-success"><code class="SQL">SELECT * FROM customers ORDER BY age DESC, last_name;</code></pre>
			<img src="https://a.radikal.ru/a19/1804/46/9b4f6df28ec3.png" alt="">

			<p> Для выборки и сортировки в случайном порядке используем <b>ORDER BY RAND()</b>; </p>
			<pre class="border border-success"><code class="SQL">SELECT last_name,first_name 
FROM customers 
ORDER BY rand(); </code></pre>
			<img src="https://a.radikal.ru/a07/1804/de/52386b71b6e7.png" alt="">

			<p>Вместо названий колонок можно использовать их порядковые номера. Это не рекомендуется, так как порядкок колонок может смениться и тогда сортировка собьется.</p>
			<pre class="border border-success"><code class="SQL">SELECT * FROM customers 
ORDER BY 3,2; </code></pre>
			<img src="https://b.radikal.ru/b03/1804/bc/204160ca2243.png" alt="">

			<p>Для ограничения выборки используем <b>LIMIT</b>, например сделаем выборку 3 случайных клиентов</p>
			<pre class="border border-success"><code class="SQL">SELECT last_name,first_name 
FROM customers 
ORDER BY rand() 
LIMIT 3; </code></pre>
			<img src="https://c.radikal.ru/c35/1804/39/ad490d2539e4.png" alt="">

			<p>Что бы сделать выборку 5 клиентов начиная например с 7го:</p>
			<pre class="border border-success"><code class="SQL">SELECT last_name,first_name 
FROM customers 
ORDER BY last_name 
LIMIT 7,5; </code></pre>
			<img src="https://b.radikal.ru/b28/1804/a6/ac0efb42789c.png" alt="">

			<p>Для постановки фильтров выборки можно использовать предикат WHERE. Например сделаем выборку всех клиентов срарше 29 лет. При этом происходит проверка каждой записи и выборка только нужных</p>
			<pre class="border border-success"><code class="SQL">SELECT last_name,age
FROM customers
WHERE age >29;</code></pre>
			<p>Для выборки всех клиентов в возрасте от 18 до 24 лет используем <b>BETWEEN</b></p>
			<pre class="border border-success"><code class="SQL">SELECT * 
FROM customers 
WHERE age BETWEEN 18 AND 24;</code></pre>
			<img src="https://c.radikal.ru/c05/1804/a2/3ded24679552.png" alt="">


			<p>Для выборки всех клиентов c фамилией начинающейся на К используем <b>LIKE</b> и знак <b>%</b></p>
			<pre class="border border-success"><code class="SQL">SELECT * 
FROM customers 
WHERE last_name LIKE 'К%';</code></pre>
			<img src="https://c.radikal.ru/c18/1804/ee/0cad87b7aea6.png" alt="">

			<p>Для выборки всех клиентов c фамилией <b>не</b> не заканчивающихся на <b>ов</b> используем <b>NOT LIKE</b></p>
			<pre class="border border-success"><code class="SQL">SELECT * 
FROM customers 
WHERE last_name NOT LIKE '%ов';</code></pre>
			<img src="https://a.radikal.ru/a38/1804/7d/61ad4351a9bc.png" alt="">

			<p>Для того чтобы выбрать всех клиентов с именами Александр и Владимир используем <b>IN</b> </p>
			<pre class="border border-success"><code class="SQL">SELECT * 
FROM customers
WHERE first_name IN ('Александр','Владимир');</code></pre>
			<img src="https://b.radikal.ru/b01/1804/9e/e6803d6cdb42.png" alt="">

			<p>Для того чтобы выбрать всех остальных клиентов используем <b>NOT IN</b> </p>
			<pre class="border border-success"><code class="SQL">SELECT * 
FROM customers
WHERE first_name NOT IN ('Александр','Владимир');</code></pre>
			<img src="https://a.radikal.ru/a38/1804/6b/9ecf2c7a3505.png" alt="">

			<p>Для определения среднего возраста клиентов используем <b>агрегирующую функцию AVG</b></p>
			<pre class="border border-success"><code class="SQL">SELECT AVG(age) FROM customers;</code></pre>
			<img src="https://c.radikal.ru/c25/1804/dd/0274d879a8ec.png" alt="">


			<p>Для возврата количества строк в таблице используем агрегирующую функцию <b>COUNT</b>. C функцией COUNT нет смысла указывать конкретную колонку, т.к. в реляционной таблице количество рядов во всех колонках одинаковое, поэтому используем всегда <b>*</b></p>
			<pre class="border border-success"><code class="SQL">SELECT COUNT(*) FROM customers;</code></pre>
			<img src="https://d.radikal.ru/d28/1804/10/055e6a4bbbef.png" alt="">


			<p> Чтобы получить список фамилий клиентов через запятую используем групповую конкатенацию <b>GROUP_CONCAT</b> </p>
			<pre class="border border-success"><code class="SQL">SELECT GROUP_CONCAT(last_name) FROM customers;</code></pre>
			<img src="https://d.radikal.ru/d05/1804/98/edee9fe56b17.png" alt="">

			<p> Что бы узнать максимальный возраст нашего клиента используем <b>MAX</b> </p>
			<pre class="border border-success"><code class="SQL">SELECT MAX(age) FROM customers;</code></pre>
			<img src="https://b.radikal.ru/b18/1804/2b/c892683c5404.png" alt="">

			<p> Что бы узнать суммарный возраст наших клиентов используем <b>MAX</b> </p>
			<pre class="border border-success"><code class="SQL">SELECT SUM(age) FROM customers;</code></pre>
			<img src="https://c.radikal.ru/c15/1804/cc/e7e0576588be.png" alt="">

			<p>Для того чтобы сгруппировать наших клиентов по фамилии, а затем по возрасту используем <b>GROUP BY</b></p>
			<pre class="border border-success"><code class="SQL">SELECT last_name, age 
FROM customers
GROUP BY last_name, age;</code></pre>
			<img src="https://c.radikal.ru/c35/1804/0d/e3eed01b396d.png" alt="">

			<p><b>Настойчиво рекомендуется</b> писать предикаты в следующем порядке, так как именно в этом порядке они выполняются на сервере:</p>
			<pre class="border border-success"><code class="SQL">--WHERE
--GROUP
--HAVING
--ORDER
--LIMIT</code></pre>



			<h4 id="task3.2">Запрос на объединение таблиц JOIN</h4>
			<p>3.2 запросы на объединение таблиц (JOIN) между сочетаниями по две, три таблицы (не менее 10 штук) Примечание: Запросы должны гибко выбирать данные из базы</p>

			<p>Для того что бы увеличить эффективность БД необходимо, что бы в таблицах не было повторяющихся значений. Для этого удалим из таблицы c объектами недвижимости 'estateObjects' колонки 'type', 'address', 'postIndex', 'rooms' и создадим на их основе отдельные таблицы из двух колонок которые будут содержать только индекс и значение, дополнительно создадим таблицу с собственниками 'landlords' и городами 'cities'. </p>
			<p>Для таблицы со списком клиентов 'customers' создадим дополнительные таблицы со статусами, гражданством 'nationality',родными языками 'language', и банками, клиентами которых являются наши клиенты 'banks'. </p>
			<p>Все дополнительные таблицы состоят из двух колонок - имя и значения и служат для того, что бы использоваться в качестве вспомогатальных таблиц для двух остальных.</p>



			<p>Удаляем лишние колонки</p>
			<pre class="border border-success"><code class="SQL">ALTER TABLE `estate_objects` DROP COLUMN `type`;
ALTER TABLE `estate_objects` DROP COLUMN `address`;
ALTER TABLE `estate_objects` DROP COLUMN `post_index`;</code></pre>

			<p>Добавляем аналогичные колонки с ID </p>
			<pre class="border border-success"><code class="SQL">ALTER TABLE `estate_objects` ADD COLUMN `typeID` INT;
ALTER TABLE `estate_objects` ADD COLUMN `addressID` INT;
ALTER TABLE `estate_objects` ADD COLUMN `postindexID` INT;
ALTER TABLE `estate_objects` ADD COLUMN `landlordID` INT;
ALTER TABLE `estate_objects` ADD COLUMN `cityID` INT;</code></pre>
			<p>Далее создаем таблицы соответствующие этим колонкам:</p>

			<pre class="border border-success"><code class="SQL">CREATE TABLE IF NOT EXISTS `mydb`.`objectType` (
  `objectTypeID` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `Type` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`objectTypeID`),
  UNIQUE INDEX `objectTypeID_UNIQUE` (`objectTypeID` ASC),
  UNIQUE INDEX `Type_UNIQUE` (`Type` ASC))
ENGINE = InnoDB;
<!--
CREATE TABLE IF NOT EXISTS `mydb`.`objectAddress` (
  `objectAddressID` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `Address` VARCHAR(100) NOT NULL,
  PRIMARY KEY (`objectAddressID`),
  UNIQUE INDEX `objectAddressID_UNIQUE` (`objectAddressID` ASC),
  UNIQUE INDEX `Address_UNIQUE` (`Address` ASC))
ENGINE = InnoDB;

CREATE TABLE IF NOT EXISTS `mydb`.`objectPostIndex` (
  `objectPostIndexID` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `PostIndex` MEDIUMINT NOT NULL,
  PRIMARY KEY (`objectPostIndexID`),
  UNIQUE INDEX `objectPostIndexID_UNIQUE` (`objectPostIndexID` ASC),
  UNIQUE INDEX `PostIndex_UNIQUE` (`PostIndex` ASC))
ENGINE = InnoDB;

CREATE TABLE IF NOT EXISTS `mydb`.`landlords` (
  `landlordID` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `landlordName` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`landlordID`),
  UNIQUE INDEX `landlordID_UNIQUE` (`landlordID` ASC),
  UNIQUE INDEX `landlordName_UNIQUE` (`landlordName` ASC))
ENGINE = InnoDB;
			
CREATE TABLE IF NOT EXISTS `mydb`.`objectCity` (
  `objectCityID` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `City` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`objectCityID`),
  UNIQUE INDEX `objectCityID_UNIQUE` (`objectCityID` ASC),
  UNIQUE INDEX `City_UNIQUE` (`City` ASC))
  ENGINE = InnoDB;
--></code></pre>
			<p>Аналогично создаем таблицы <b>objectAddress</b>, <b>objectPostIndex</b>, <b>landlords</b>, <b>objectCity</b> </p>
			<p>Заполняем эти таблицы с помощью LOAD DATA.</p>
			<p>Вставляем в таблицу estate_objects значения созданных нами только что колонок</p>
			<pre class="border border-success"><code class="SQL"><b>UPDATE estate_objects 
	SET typeID = 1 
	WHERE `idreal estate_objects` = 1; --для того чтобы использовать в запросе название столбца с пробелом внутри используем символ `</b></code></pre>
			<p>Таким же образом заполняем новые ячейки таблицы estate_objects полностью</p>

			<p>Таким образом получается система из одной основной таблицы и 5 вспомогательных таблиц</p>

			<div class="row">
				<div class="col-12 mb-1"><img style="width: 100%" src="http://i.yapx.ru/BMPwF.png" alt=""></div>
				<div class="col-3"><img class="img-fluid" src="https://a.radikal.ru/a31/1804/22/b107cfcb4905.png" alt=""></div>
				<div class="col-3"><img class="img-fluid" src="https://c.radikal.ru/c00/1804/3d/76ba32a5bf30.png" alt=""></div>
				<div class="col-3"><img class="img-fluid" src="https://d.radikal.ru/d13/1804/1b/5ef599d49cea.png" alt=""></div>
				<div class="col-3"><img src="https://d.radikal.ru/d14/1804/32/b4da9d1e6232.png" alt=""></div>
				<div class="col-3 mt-1"><img src="https://a.radikal.ru/a31/1804/71/a6ca91fb3931.png" alt=""></div>
				<div class="col-2"></div>
			</div>
			<!--Далее нужно вставить в основные ячейки соответствующие индексы и наполнить вспомогательные таблицы через LOAD DATA, далее JOHN-->
			<p>Далее используем <b>INNER JOHN</b> для объединения основной таблицы estate_objects и вспомогательных таблиц </p>
			<pre class="border border-success"><code class="SQL">SELECT estate_objects.`idreal estate_objects`, estate_objects.area, estate_objects.rooms,
estate_objects.description, estate_objects.price, objectType.Type, objectaddress.Address, 
objectpostindex.PostIndex, landlords.landlordName, objectCity.City
	FROM estate_objects
		INNER JOIN objectType ON estate_objects.typeID = objectType.objectTypeID
		INNER JOIN objectaddress ON estate_objects.addressID = objectaddress.objectAddressID
		INNER JOIN objectpostindex ON estate_objects.postindexID = objectpostindex.objectPostIndexID
		INNER JOIN landlords ON estate_objects.landlordID  = landlords.landlordID
		INNER JOIN objectCity ON estate_objects.cityID = objectCity.objectCityID;</code></pre>
			<img style="width: 100%" src="http://i.yapx.ru/BMPvG.png" alt="">

			<p>Используя <b>LEFT OUTER JOIN</b> копируются из левой таблицы(первой в записи) не только данные у которых есть соответствия во второй, но и остальные </p>
			<pre class="border border-success"><code class="SQL">SELECT estate_objects.`idreal estate_objects`, estate_objects.area, estate_objects.rooms,
estate_objects.description, estate_objects.price, objectCity.City
	FROM objectCity
		LEFT OUTER JOIN estate_objects ON estate_objects.cityID = objectCity.objectCityID;</code></pre>
			<img style="width: 100%" src="http://i.yapx.ru/BMP0n.png" alt="">
			<p>Таким образом отобразились даже те города которые есть в таблице, но в которых нет наших объектов недвижимости</p>
			<p>Используя RIGHT OUTER JOIN копируются из правой таблицы(второй в записи) не только данные у которых есть соответствия во второй, но и остальные</p>
			<pre class="border border-success"><code class="SQL">SELECT estate_objects.`idreal estate_objects`, estate_objects.area, estate_objects.rooms,
estate_objects.description, estate_objects.price, objectCity.City
	FROM objectCity
		RIGHT OUTER JOIN estate_objects ON estate_objects.cityID = objectCity.objectCityID;</code></pre>
			<img src="http://i.yapx.ru/BMP0z.png" alt="">

			<p>Для того что бы скопировать все записи из всех таблиц и по возможности установить соответствие друг другу используется полное объединение <b>FULL OUTER JOIN</b></p>

			<pre class="border border-success"><code class="SQL">SELECT * FROM estate_objects
	    	FULL OUTER JOIN objectCity
	    	ON estate_objects.cityID = objectCity.city;
		    </code></pre>
			<img class="img-fluid" src="http://i.yapx.ru/BMP5y.png" alt="">
			<p>(!) В MySQL нет полного внешнего объединения. Прийдетсяписать через левые:</p>


			<pre class="border border-success"><code class="SQL">SELECT * FROM estate_objects LEFT JOIN objectCity ON estate_objects.cityID = objectCity.city
UNION
SELECT * FROM objectCity  LEFT JOIN estate_objects ON estate_objects.cityID = objectCity.city;
		    </code></pre>
			<img class="img-fluid" src="http://i.yapx.ru/BMP6v.png" alt="">

			<p>Кросс объединение делается с помощью <b>CROSS JOIN</b>. В результате каждой записи левой таблицы ставятся в соответствие все записи правой. Нет условия связи. </p>
			<pre class="border border-success"><code class="SQL">SELECT *
	FROM estate_objects
		CROSS JOIN objectCity;</code></pre>

		</section>
		<section>
			<h2 class="mt-5" id="task4.1">Задание 4.1</h2>
			<p>Создайте необходимые индексы в таблицах.</p>
			<p>Индексы необходимо создавать там где планируется часто использовать поиск. Например клиентов менеджеры будут часто искать по имени и фамилии. Создаем индекс в таблице customers. В таблице с объектами недвижимости будут часто искать по цене и площади, создаем индексы отдельно для цены и площади. Индексирование делает операции выборки быстрее, а вставку медленнее. Индексировать можно только простые типы данных! Нельзя индексировать такие типы как например text.</p>
			<pre class="border border-success"><code class="SQL">
CREATE INDEX idx_customers_name
ON customers(last_name, first_name);

CREATE INDEX idx_object_area ON estate_objects (area);

CREATE INDEX idx_object_price ON estate_objects (price);      	    
		    </code></pre>

			<h2 id="task4.2" class="mt-5">Задание 4.2</h2>
			<p>Проанализируйте эффективность запросов из предыдущего задания оператором EXPLAIN</p>
			<p>Для анализа медленных запросов в Mysql используется инструкция EXPLAIN. Проанализируем запросы с использованием этой инструкции:</p>

			<pre class="border border-success"><code class="SQL">
EXPLAIN SELECT last_name,date_of_birth FROM customers;
		    </code></pre>
			<p>В результате анализа запроса в колонке key мы видим какой индекс использовался при запросе (idx_customers_name). В колонке row мы видим количество обработанных строк, чем оно меньше тем быстрее будет запрос! </p>
			<img class="img-fluid" src="https://i.yapx.ru/BREef.png" alt="">

			<pre class="border border-success"><code class="SQL">
EXPLAIN SELECT DISTINCT age FROM customers;

EXPLAIN SELECT last_name,first_name
FROM customers
ORDER BY last_name DESC;

EXPLAIN SELECT last_name,first_name 
FROM customers 
ORDER BY rand(); 

EXPLAIN SELECT AVG(age) FROM customers;

EXPLAIN SELECT last_name, age 
FROM customers
GROUP BY last_name, age;

		    </code></pre>
			<img class="img-fluid" src="https://i.yapx.ru/BREoC.png" alt="">
			<img class="img-fluid" src="https://i.yapx.ru/BREoy.png" alt="">
			<pre class="border border-success"><code class="SQL">
EXPLAIN SELECT estate_objects.`idreal estate_objects`, estate_objects.area, estate_objects.rooms,
estate_objects.description, estate_objects.price, objectType.Type, objectaddress.Address, 
objectpostindex.PostIndex, landlords.landlordName, objectCity.City
	FROM estate_objects
		INNER JOIN objectType ON estate_objects.typeID = objectType.objectTypeID
		INNER JOIN objectaddress ON estate_objects.addressID = objectaddress.objectAddressID
		INNER JOIN objectpostindex ON estate_objects.postindexID = objectpostindex.objectPostIndexID
		INNER JOIN landlords ON estate_objects.landlordID  = landlords.landlordID
		INNER JOIN objectCity ON estate_objects.cityID = objectCity.objectCityID;
		    </code></pre>
			<img class="img-fluid" src="https://i.yapx.ru/BREu0.png" alt="">
		</section>
		<section>
			<h2 class="mt-5" id="task5">Задание 5</h2>
			<p>Напишите запросы на удаление и обновление данных из таблиц (предусмотреть удаления и обновления данных по условию)</p>
			<p>Запрос на вставку данных в таблицу estate_objects:</p>
			<pre class="border border-success"><code class="SQL">
INSERT INTO estate_objects 
	    (area, rooms, description, price, typeID, addressID, postindexID, landlordID, cityID) 
values('50', '5', 'Маленькая но пятикомнатная квартира', '5000000', '1', '1', '1', '1', '1' );			
		    </code></pre>
			<img class="img-fluid" src="http://i.yapx.ru/BTD43.png" alt="">
	<p>Запрос на обновление данных из таблицы по условию:</p>
	<p>Обратные кавычки используем для обращения к полю в условии WHERE к `idreal estate_objects` т.к. оно имеет ПРОБЕЛ.</p>
			<pre class="border border-success"><code class="SQL">
UPDATE estate_objects SET 
	    area = '100', rooms = '8', description = 'Площадь возросла вдвое за счет пристройки к внешней стене здания!' 
	    WHERE `idreal estate_objects` = '10';
		    </code></pre>
			<img class="img-fluid" src="http://i.yapx.ru/BTEWN.png" alt="">	
	<p>Запрос на удаление данных из таблицы по условию:</p>
	<p>Удалим все объекты число комнат которых больше шести</p>
			<pre class="border border-success"><code class="SQL">
DELETE FROM estate_objects WHERE rooms >= '6';
		    </code></pre>
			<img class="img-fluid" src="http://i.yapx.ru/BTEed.png" alt="">						 				 
		</section>
	</div>


	<script src="highlight.pack.js"></script>
	<script>
		hljs.initHighlightingOnLoad();
	</script>
</body>

</html>
